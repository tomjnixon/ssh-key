#!/usr/bin/env python2
import socket
import os
import subprocess
import pwd
import shutil
import sys
import glob
import re
import collections

SSH_DIR = os.path.expanduser("~/.ssh")
CONFIG = os.path.join(SSH_DIR, "config")
CONFIG_HEAD = os.path.join(SSH_DIR, "config.head")
CONFIG_KEYS = os.path.join(SSH_DIR, "config.keys")
CONFIG_TAIL = os.path.join(SSH_DIR, "config.tail")
CONFIG_LAST = os.path.join(SSH_DIR, "config.last")
KNOWN_HOSTS = os.path.join(SSH_DIR, "known_hosts")
GENERATED_STRING="# generated by ssh-key; do not edit"

def get_user():
    return pwd.getpwuid(os.getuid()).pw_name

def parse_user_host(user_host):
    if "@" in user_host:
        return tuple(user_host.split("@", 1))
    else:
        return (None, user_host)

def get_key_name(hostname, port):
    return "id_{host}_{port}".format(host=hostname, port=port)

def get_privkey_fname(key_name, for_host=None):
    if for_host is not None:
        return os.path.join(SSH_DIR, "for_" + for_host, key_name)
    else:
        return os.path.join(SSH_DIR, key_name)

def ssh_copy_id(user_host, port, pubkey_fname):
    """A re-implementation of ssh-copy-id, that checks to see if the key
    already exists in the authorized_keys file on the remote side, instead of
    testing by logging in.

    This allows us to use all our tricks to log in (existing keys, existing
    connections) for when we want to add a new key.

    The alternative to this would be to try logging in with only the key to be
    added, however this is dificult to set up, as the '-i' option in ssh only
    adds to the list of keys specified in the config file, so we would have to
    re-write that first.
    """
    command = ("exec sh -c '"
               "read -r line ; " # read the line to add
               "key=`echo \"$line\" | cut -d \" \" -f 2` ; " # extract the key field
               "cd ; umask 077 ; "
               # if the file does not exist, or the key is not already in the file, add it
               "if ! [ -f .ssh/authorized_keys ] || ! grep -Fq \"$line\" .ssh/authorized_keys ; then "
                   "mkdir -p .ssh && echo \"$line\" >> .ssh/authorized_keys || exit 1 ; "
                   "echo \"key successfully installed\" ; "
               "else "
                   "echo \"key already installed\" ; "
               "fi ; "
               # deal with selinux, as in ssh-copy-id
               "if type restorecon >/dev/null 2>&1 ; then restorecon -F .ssh .ssh/authorized_keys ; fi'")
    with open(pubkey_fname) as pubkey_file:
        subprocess.check_call(["ssh", "-p", str(port), user_host, command], stdin=pubkey_file)

def cmd_new(args):
    for user_host in args.hosts:
        user, hostname = parse_user_host(user_host)
        
        key_name = get_key_name(hostname, args.port)
        privkey_fname = get_privkey_fname(key_name, args.for_host)
        pubkey_fname = privkey_fname + ".pub"

        # make sure the key directory exists
        key_dir = os.path.dirname(pubkey_fname)
        if not os.path.exists(key_dir):
            os.mkdir(key_dir)
        
        # generate a key if one doesn't exist already
        if not os.path.exists(privkey_fname):
            local_hostname = args.for_host if args.for_host is not None else socket.getfqdn()
            comment = "{user}@{local_hostname} {key_name}".format(
                    user=get_user(),
                    local_hostname=local_hostname,
                    key_name=key_name)
            subprocess.check_call(["ssh-keygen", "-C", comment, "-f", privkey_fname])
        else:
            print "using existing key for {user_host}".format(user_host=user_host)

        if args.for_host is not None:
            print "generated keys:"
            print "    " + pubkey_fname
            print "    " + privkey_fname
        
        if args.service:
            # print the public key for easy copying
            print "generated key for {user_host}:".format(user_host=user_host)
            with open(pubkey_fname) as pk_f:
                print pk_f.read()
        else:
            ssh_copy_id(user_host, args.port, pubkey_fname)
        
        update_configs()

def get_keys():
    """Get all the private key names from the .ssh directory, with associated remote
    hostnames and ports."""
    # find keys named "id_*.pub" with contents like
    # "ssh-rsa key local_user@local_host id_hostname_port"
    for fname in glob.glob(os.path.join(SSH_DIR, "id_*.pub")):
        parts = open(fname).read().split()
        if len(parts) != 4: continue
        type, key, comment_local, comment_name = parts
        
        parts = comment_name.split("_")
        if len(parts) != 3: continue
        id, hostname, port = parts
        if id != "id": continue
        
        priv_fname = fname[:-len(".pub")]
        
        yield priv_fname, hostname, port

# [hostname]:port
HOST_PORT_REGEX = re.compile(r"^\[([^\]]+)\]:([0-9]+)$")

def parse_host_port(host_port):
    """Parse host and port from known_hosts, as defined in sshd(8)."""
    m = HOST_PORT_REGEX.match(host_port)
    if m:
        return m.group(1, 2)
    else:
        return (host_port, "22")

def read_known_hosts():
    """Read the known hosts file, yielding (host, port, type, key) tuples for
    each known host. Lines with multiple hosts are split into separate entries."""
    with open(KNOWN_HOSTS) as f:
        for line in f:
            hosts_str, type, key = line.split()
            for host, port in map(parse_host_port, hosts_str.split(",")):
                yield host, port, type, key

def get_same_host_index():
    """Using known_hosts, get a dict from (host, port) to sets of (host, port)
    which share the same public key."""
    known_hosts = list(read_known_hosts())
    
    key_to_hosts = collections.defaultdict(set)
    for host, port, type, key in known_hosts:
        key_to_hosts[key].add((host, port))
    
    host_to_hosts = {}
    for host, port, type, key in known_hosts:
        other_hosts = key_to_hosts[key]
        if len(other_hosts) > 1:
            host_to_hosts[(host, port)] = key_to_hosts[key]
    
    return host_to_hosts

def update_config_keys():
    """Update the config.keys file from the comments in public keys, getting
    equivalent hosts from known_hosts."""
    same_host_index = get_same_host_index()
    
    with open(CONFIG_KEYS, 'w') as f:
        f.write(GENERATED_STRING + "\n")
        for priv_fname, orig_hostname, orig_port in get_keys():
            equivalent_hosts = same_host_index.get((orig_hostname, orig_port),
                                                   [(orig_hostname, orig_port)])
            for hostname, port in equivalent_hosts:
                f.writelines([
                    "Match host {hostname} exec \"test %p = {port}\"\n".format(
                        hostname=hostname,
                        port=port),
                    "    IdentitiesOnly yes\n",
                    "    IdentityFile {priv_fname}\n".format(priv_fname=priv_fname)
                ])

def allow_write_config():
    """Are we allowed to write to the ssh config?
    This is based on the config.last file which contains the last contents we
    wrote to the actual config file. If this doesn't exist, or the contents
    have changed, return false.
    """
    if not os.path.exists(CONFIG):
        return True
    
    if not os.path.exists(CONFIG_LAST):
        sys.stderr.write("Config was not generated by ssh-key; not re-generating.\n")
        sys.stderr.write("Remove {config} to allow re-generation.\n".format(config=CONFIG))
        sys.stderr.write("To keep your existing config, copy it to {config_head}.\n".format(config_head=CONFIG_HEAD))
        return False # config exists and not generated
    
    # was it changed since last generated?
    if subprocess.call(["diff", "-c", CONFIG, CONFIG_LAST]) != 0:
        sys.stderr.write("Config has been changed since last generated; not re-generating\n")
        sys.stderr.write("Remove {config} to allow re-generation.\n".format(config=CONFIG))
        sys.stderr.write("If you want to keep the above changes, apply them to {config_head}.\n".format(config_head=CONFIG_HEAD))
        return False
    else:
        return True

def cat_configs():
    if not allow_write_config():
        exit(1)
    
    input_files = filter(os.path.exists, [CONFIG_HEAD, CONFIG_KEYS, CONFIG_TAIL])
    
    with open(CONFIG, "w") as fout:
        fout.write(GENERATED_STRING + "\n")
        for input_file in input_files:
            with open(input_file) as fin:
                for line in fin:
                    fout.write(line)
                fout.write("\n")
    
    shutil.copyfile(CONFIG, CONFIG_LAST)

def update_configs():
    update_config_keys()
    cat_configs()

def cmd_config(args):
    update_configs()

def parse_args():
    import argparse
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers()
    
    new_cmd = subparsers.add_parser('new')
    new_cmd.add_argument('-p', dest="port", type=int, default=22, help="port")
    new_cmd.add_argument('-s', dest="service", action="store_true",
            help="Generate a service key; don't install it on the host.")
    new_cmd.add_argument("--for", dest="for_host",
                         help="Generate a SSH key for another system.")
    new_cmd.add_argument('hosts', metavar='host', nargs='+', help="hostnames")
    new_cmd.set_defaults(func=cmd_new)
    
    config_cmd = subparsers.add_parser('config')
    config_cmd.set_defaults(func=cmd_config)
    
    return parser.parse_args()

def main():
    args = parse_args()
    args.func(args)

if __name__ == "__main__":
    main()
