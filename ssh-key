#!/usr/bin/env python2
import socket
import os
import subprocess
import pwd
import shutil
import sys
import glob
import re
import collections

SSH_DIR = os.path.expanduser("~/.ssh")
CONFIG = os.path.join(SSH_DIR, "config")
CONFIG_HEAD = os.path.join(SSH_DIR, "config.head")
CONFIG_KEYS = os.path.join(SSH_DIR, "config.keys")
CONFIG_TAIL = os.path.join(SSH_DIR, "config.tail")
CONFIG_LAST = os.path.join(SSH_DIR, "config.last")
KNOWN_HOSTS = os.path.join(SSH_DIR, "known_hosts")
GENERATED_STRING="# generated by ssh-key; do not edit"

def get_user():
    return pwd.getpwuid(os.getuid()).pw_name

def canonicalise_hostname(hostname):
    return socket.getfqdn(hostname)

def parse_user_host(user_host):
    if "@" in user_host:
        return tuple(user_host.split("@", 1))
    else:
        return (None, user_host)

def get_key_name(hostname, port):
    return "id_{host}_{port}".format(host=hostname, port=port)

def get_privkey_fname(key_name):
    return os.path.join(SSH_DIR, key_name)

def cmd_new(args):
    for user_host in args.hosts:
        user, unqual_hostname = parse_user_host(user_host)
        hostname = canonicalise_hostname(unqual_hostname)
        
        key_name = get_key_name(hostname, args.port)
        privkey_fname = get_privkey_fname(key_name)
        pubkey_fname = privkey_fname + ".pub"
        
        # generate a key if one doesn't exist already
        if not os.path.exists(privkey_fname):
            comment = "{user}@{local_hostname} {key_name}".format(
                    user=get_user(),
                    local_hostname=socket.getfqdn(),
                    key_name=key_name)
            subprocess.check_call(["ssh-keygen", "-C", comment, "-f", privkey_fname])
        
        if args.service:
            # print the public key for easy copying
            print "generated key for user_host:"
            with open(pubkey_fname) as pk_f:
                print pk_f.read()
        else:
            # copy the key
            subprocess.call(["ssh-copy-id",
                             "-i", pubkey_fname,
                             "-o", "ControlPath=none", # work around bug in ssh-copy-id
                             "-p", str(args.port),
                             user_host])
        
        update_configs()

def get_keys():
    """Get all the private key names from the .ssh directory, with associated remote
    hostnames and ports."""
    # find keys named "id_*.pub" with contents like
    # "ssh-rsa key local_user@local_host id_hostname_port"
    for fname in glob.glob(os.path.join(SSH_DIR, "id_*.pub")):
        parts = open(fname).read().split()
        if len(parts) != 4: continue
        type, key, comment_local, comment_name = parts
        
        parts = comment_name.split("_")
        if len(parts) != 3: continue
        id, hostname, port = parts
        if id != "id": continue
        
        priv_fname = fname[:-len(".pub")]
        
        yield priv_fname, hostname, port

# [hostname]:port
HOST_PORT_REGEX = re.compile(r"^\[([^\]]+)\]:([0-9]+)$")

def parse_host_port(host_port):
    """Parse host and port from known_hosts, as defined in sshd(8)."""
    m = HOST_PORT_REGEX.match(host_port)
    if m:
        return m.group(1, 2)
    else:
        return (host_port, "22")

def read_known_hosts():
    with open(KNOWN_HOSTS) as f:
        for line in f:
            hosts_str, type, key = line.split()
            for host, port in map(parse_host_port, hosts_str.split(",")):
                yield host, port, type, key

def get_same_host_index():
    """Get an dict from (host, port) to sets of (host, port) which share the
    same public key."""
    known_hosts = list(read_known_hosts())
    
    key_to_hosts = collections.defaultdict(set)
    for host, port, type, key in known_hosts:
        key_to_hosts[key].add((host, port))
    
    host_to_hosts = {}
    for host, port, type, key in known_hosts:
        other_hosts = key_to_hosts[key]
        if len(other_hosts) > 1:
            host_to_hosts[(host, port)] = key_to_hosts[key]
    
    return host_to_hosts

def update_config_keys():
    same_host_index = get_same_host_index()
    
    with open(CONFIG_KEYS, 'w') as f:
        f.write(GENERATED_STRING + "\n")
        for priv_fname, orig_hostname, orig_port in get_keys():
            equivalent_hosts = same_host_index.get((orig_hostname, orig_port),
                                                   (orig_hostname, orig_port))
            for hostname, port in equivalent_hosts:
                f.writelines([
                    "Match host {hostname} exec \"test %p = {port}\"\n".format(
                        hostname=hostname,
                        port=port),
                    "    IdentitiesOnly yes\n",
                    "    IdentityFile {priv_fname}\n".format(priv_fname=priv_fname)
                ])

def allow_write_config():
    if not os.path.exists(CONFIG):
        return True
    
    if not os.path.exists(CONFIG_LAST):
        return False # config exists and not generated
    
    # was it changed since last generated?
    return subprocess.call(["diff", "-c", CONFIG, CONFIG_LAST]) == 0

def cat_configs():
    if not allow_write_config():
        sys.stderr.write("config not generated by ssh-key; not re-generating\n")
        exit(1)
    
    input_files = filter(os.path.exists, [CONFIG_HEAD, CONFIG_KEYS, CONFIG_TAIL])
    
    with open(CONFIG, "w") as fout:
        fout.write(GENERATED_STRING + "\n")
        for input_file in input_files:
            with open(input_file) as fin:
                for line in fin:
                    fout.write(line)
                fout.write("\n")
    
    shutil.copyfile(CONFIG, CONFIG_LAST)

def update_configs():
    update_config_keys()
    cat_configs()

def cmd_config(args):
    update_configs()

def parse_args():
    import argparse
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers()
    
    new_cmd = subparsers.add_parser('new')
    new_cmd.add_argument('-p', dest="port", type=int, default=22, help="port")
    new_cmd.add_argument('-s', dest="service", action="store_true",
            help="Generate a service key; don't install it on the host.")
    new_cmd.add_argument('hosts', metavar='host', nargs='+', help="hostnames")
    new_cmd.set_defaults(func=cmd_new)
    
    config_cmd = subparsers.add_parser('config')
    config_cmd.set_defaults(func=cmd_config)
    
    return parser.parse_args()

if __name__ == "__main__":
    args = parse_args()
    args.func(args)
